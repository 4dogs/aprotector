    
    上回分析到CodeVerify.h头文件中VerifyData结构体。它的结构非常庞杂，且引用众多，完整引用图以后列举，现在先来看VerifyData下其中一个叶子结构体VfyBasicBlock:

/*
Structure representing a basic block.

This is used for liveness analysis, which is a reverse-flow algorithm,
so we need to mantain a list of predecessors for each block.

"liveRegs" indicates the set of registers that are live at the end of
the basic block (after the last instruction has executed).  Successor
blocks will compare their results with this to see if this block needs
to be re-evaluated.  Note that this is not the same as the contents of
the RegisterLine for the last instruction in the block (which reflects
the state *before* the instruction has executed).

该结构代表一个基本程序块。

被使用于生命周期分析，采用反流算法，
因此我们需要维护一个原始程序块列表。

“liveRegs”标识基本程序块末尾的寄存器集合（在最后一条指令执行后）。后续的
代码块将使用它比较他们的结果来看该代码块是否需要重新评估。注意，作为代码
块最后一条指令的RegisterLine的内容是不同的（反映了指令执行前的状态）。

NOTE TODO：什么是反流算法reverse-flow algorithm
*/
struct VfyBasicBlock {
    /*
    第一条指令的地址
    */
    u4              firstAddr;      /* address of first instruction */
    /*
    最后一条指令的地址
    */
    u4              lastAddr;       /* address of last instruction */
    /*
    流向这里的基本块的原始引用
    */
    PointerSet*     predecessors;   /* set of basic blocks that can flow here */
    /*
    每个寄存器的生命周期状态
    */
    BitVector*      liveRegs;       /* liveness for each register */
    /*
    输入设置已被改变，必须重新评估
    */
    bool            changed;        /* input set has changed, must re-eval */
    /*
    代码块至少被访问了一次
    */
    bool            visited;        /* block has been visited at least once */
};

    该结构体是校验器结构体虽然不是原子结构体，但却是一个基本单元。在后面的分析校验会用到。PointerSet指针目前猜测是在Dex解为字节流进行结构化赋值的，而BitVector指针注释说的很明白，参见

/*
 * Expanding bitmap, used for tracking resources.  Bits are numbered starting
 * from zero.
 *
 * All operations on a BitVector are unsynchronized.
 */
struct BitVector {
    bool    expandable;     /* expand bitmap if we run out? */
    u4      storageSize;    /* current size, in 32-bit words */
    u4*     storage;
};

    扩展位图，用于跟踪资源。bit位从0开始编号。所有在BitVector上的操作都是不同步的。这里的storage应该是资源类的引用了。

    为了能够对这一模块有更深入的了解，下面是几乎完整的analysis模块重要结构体交叉引用图，参见具体日志
...






    

