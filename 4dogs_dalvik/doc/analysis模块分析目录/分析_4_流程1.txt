    
    我们从DexVerify.cpp->verifyMethod(Method* meth)进入来看校验方法的流程，前面已知校验类就是校验方法。
static bool verifyMethod(Method* meth)
{
    ... 
    校验器VerifierData vdata初始化，分配空间、存储信息等
    ...
    计算指令宽度，计算操作码 NOTE TODO：
    if (!computeWidthsAndCountOps(&vdata))
        goto bail;
    ...
    创建未初始化的实例集合
    vdata.uninitMap = dvmCreateUninitInstanceMap(meth, vdata.insnFlags,
        vdata.newInstanceCount);
    if (vdata.uninitMap == NULL)
        goto bail;
    扫描TryCatch块
    if (!scanTryCatchBlocks(meth, vdata.insnFlags))
        goto bail;
    校验指令
    if (!verifyInstructions(&vdata))
        goto bail;
    校验代码流
    if (!dvmVerifyCodeFlow(&vdata)) {
        //ALOGD("+++ %s failed code flow", meth->name);
    ...
    释放内存空间、引用等销毁工作
    ...
    return result;
}   
   这段Code，dvmVerifyCodeFlow()是最重要的关键校验函数，之前代码功能为校验代码流做很多前期工作。computeWidthsAndCountOps(&vdata)函数遍历单个方法method所有指令进行合法性校验。同时调用libdex辅助类库计算解析opcode操作码，同时知道了 CodeUnit代码单元（对应第一个问题）即使dex文件映射在内存和指令一一对应的实际字节码，可以这样说，进过解析转码后的字节码是操作码，之前的是代码单元。scanTryCatchBlocks()则对try catch{}块中的每一条指令都做了处理：标识，校验。


 



